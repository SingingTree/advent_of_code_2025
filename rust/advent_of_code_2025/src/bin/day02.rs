use std::collections::HashSet;

fn digit_count(n: u128) -> usize {
    n.to_string().len()
}

/// Returns the (min, max) values that have exactly `num_digits` digits.
///
/// Examples:
/// - digit_bounds(1) = (1, 9)
/// - digit_bounds(2) = (10, 99)
/// - digit_bounds(3) = (100, 999)
///
/// Note: For 1 digit, we return 1 (not 0) as the minimum since we're
/// counting positive integers only.
fn digit_bounds(num_digits: usize) -> (u128, u128) {
    let min_value = if num_digits == 1 {
        1
    } else {
        10u128.pow(num_digits as u32 - 1)
    };
    let max_value = 10u128.pow(num_digits as u32) - 1;
    (min_value, max_value)
}

/// Finds the range of seed values that generate pattern-matching numbers.
///
/// Pattern-matching numbers are generated by: `seed * multiplier`
/// - The `multiplier` encodes a repeating pattern (e.g., 101 for palindromes like xyx,
///   10001 for patterns like xyxyx, etc.)
/// - The `seed` is the base value with exactly `digit_count` digits
///
/// This function finds which seed values `x` satisfy:
/// 1. `x * multiplier` falls within `[range_start, range_end]`
/// 2. `x` has exactly `digit_count` digits
///
/// Returns `Some((min_x, max_x))` if valid seeds exist, `None` otherwise.
///
/// # Example
/// For palindromes between 500-900 with 1-digit seeds:
/// - multiplier = 101 (pattern for xyx)
/// - digit_count = 1 (seed must be in [1, 9])
/// - x * 101 must be in [500, 900]
/// - So x ∈ [⌈500/101⌉, ⌊900/101⌋] = [5, 8]
/// - Result: Some((5, 8)) → generates 505, 606, 707, 808
fn valid_digit_range(
    digit_count: usize,
    multiplier: u128,
    range_start: u128,
    range_end: u128,
) -> Option<(u128, u128)> {
    let (min_digits_value, max_digits_value) = digit_bounds(digit_count);
    let mut min_value = range_start.div_ceil(multiplier);
    let mut max_value = range_end / multiplier;

    min_value = min_value.max(min_digits_value);
    max_value = max_value.min(max_digits_value);

    if min_value <= max_value {
        Some((min_value, max_value))
    } else {
        None
    }
}

/// Generates a multiplier for repeating digit patterns using geometric series.
///
/// Computes: 1 + base + base² + ... + base^(repeat_count-1)
/// Using the formula: (base^n - 1) / (base - 1)
///
/// # Examples
/// - repeated_multiplier(10, 2) = 1 + 10 = 11 (for patterns like 55, 66, 77)
/// - repeated_multiplier(100, 3) = 1 + 100 + 10000 = 10101 (for patterns like 50505)
/// - repeated_multiplier(1000, 2) = 1 + 1000 = 1001 (for patterns like 123123)
fn repeated_multiplier(base: u128, repeat_count: usize) -> u128 {
    (base.pow(repeat_count as u32) - 1) / (base - 1)
}

/// Returns all proper divisors of n (divisors less than n).
///
/// # Example
/// - proper_divisors(6) = [1, 2, 3]
/// - proper_divisors(12) = [1, 2, 3, 4, 6]
fn proper_divisors(n: usize) -> Vec<usize> {
    (1..n).filter(|&i| n % i == 0).collect()
}

fn parse_ranges(input: &str) -> Vec<(u128, u128)> {
    input
        .trim()
        .split(',')
        .filter_map(|range_text| {
            let trimmed = range_text.trim();
            if trimmed.is_empty() {
                return None;
            }
            let (start_str, end_str) = trimmed.split_once('-')?;
            let start = start_str.parse().ok()?;
            let end = end_str.parse().ok()?;
            Some((start, end))
        })
        .collect()
}

/// Sums all numbers with simple repeating digit patterns in the given range.
///
/// Finds numbers of the form `pattern * (10^k + 1)` where k is the pattern digit count:
/// - k=1: 11, 22, 33, ..., 99
/// - k=2: 101, 202, 303, ..., 9999
/// - k=3: 1001, 2002, ..., 999999
///
/// Uses arithmetic series formula to sum efficiently without iteration.
fn sum_invalid_in_range_part1(start: u128, end: u128) -> u128 {
    let mut sum = 0u128;

    // Calculate tight bounds for pattern sizes based on range boundaries
    // Use ceil for min (to catch patterns that might reach into our range)
    // Use floor for max (patterns generate ~2*len digits, so odd max digits can't be halved evenly)
    // Example: range [1001, 50005] → min = 4.div_ceil(2) = 2, max = 5/2 = 2
    let min_digits_in_pattern = digit_count(start).div_ceil(2).max(1);
    let max_digits_in_pattern = digit_count(end) / 2;

    for pattern_digit_count in min_digits_in_pattern..=max_digits_in_pattern {
        // Example 1: pattern_digit_count = 1 → base = 10, multiplier = 11
        //   Seed 5 → 5 × 11 = 55
        // Example 2: pattern_digit_count = 2 → base = 100, multiplier = 101
        //   Seed 12 → 12 × 101 = 1212
        let base = 10u128.pow(pattern_digit_count as u32);
        let multiplier = base + 1;

        if let Some((x_min, x_max)) = valid_digit_range(pattern_digit_count, multiplier, start, end)
        {
            // Use arithmetic sum: sum = n × (first + last) / 2
            // Then multiply by the pattern multiplier since each seed generates seed × multiplier
            // Example: seeds [12, 13, 14] with multiplier 101
            //   count = 3, sum = 101 × 3 × (12 + 14) / 2 = 101 × 3 × 13 = 3939
            //   Which equals: 1212 + 1313 + 1414 = 3939 ✓
            let count = x_max - x_min + 1;
            sum += multiplier * count * (x_min + x_max) / 2;
        }
    }

    sum
}

/// Sums all numbers with complex repeating digit patterns in the given range.
///
/// Finds numbers where a digit pattern repeats multiple times:
/// - 123123 (pattern "123" repeated 2 times)
/// - 12341234 (pattern "1234" repeated 2 times)
/// - 123123123 (pattern "123" repeated 3 times)
///
/// For each possible total digit count, tries all valid pattern sizes (proper divisors).
/// Uses a HashSet to avoid double-counting numbers that match multiple patterns.
fn sum_invalid_in_range_part2(start: u128, end: u128) -> u128 {
    let mut invalids = HashSet::new();

    let min_digits = digit_count(start);
    let max_digits = digit_count(end);

    // Process each digit count in the range
    for total_digits in min_digits..=max_digits {
        let (min_digits_value, max_digits_value) = digit_bounds(total_digits);
        // Narrow the search range to numbers with exactly `total_digits` digits
        let range_start = if total_digits == min_digits {
            start
        } else {
            min_digits_value
        };
        let range_end = if total_digits == max_digits {
            end
        } else {
            max_digits_value
        };

        // Try all valid pattern sizes (proper divisors of total_digits)
        // For 6-digit numbers: try patterns of size 1, 2, 3 (which repeat 6, 3, 2 times)
        for k in proper_divisors(total_digits) {
            let repeat_count = total_digits / k;
            // Example: k=3, repeat_count=2, base=1000, multiplier=1001
            // Seed 123 → 123 × 1001 = 123123
            let base = 10u128.pow(k as u32);
            let multiplier = repeated_multiplier(base, repeat_count);

            if let Some((x_min, x_max)) = valid_digit_range(k, multiplier, range_start, range_end) {
                // Generate all matching numbers and add to HashSet
                // HashSet automatically deduplicates if a number matches multiple patterns
                invalids.extend((x_min..=x_max).map(|x| x * multiplier));
            }
        }
    }

    invalids.into_iter().sum()
}

fn main() {
    let input = include_str!("../../../../inputs/day02.txt");
    let ranges = parse_ranges(input);

    let part1_total: u128 = ranges
        .iter()
        .map(|&(start, end)| sum_invalid_in_range_part1(start, end))
        .sum();
    println!("Part1: {}", part1_total);

    let part2_total: u128 = ranges
        .iter()
        .map(|&(start, end)| sum_invalid_in_range_part2(start, end))
        .sum();
    println!("Part2: {}", part2_total);
}
